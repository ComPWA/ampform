# pylint: disable=import-error, import-outside-toplevel
# pyright: reportMissingImports=false
"""Abbreviated the annotations generated by sphinx-autodoc.

It's not necessary to generate the full path of type hints, because they are
rendered as clickable links.

See also https://github.com/sphinx-doc/sphinx/issues/5868.
"""

from typing import List

import sphinx.domains.python
from docutils import nodes
from sphinx.addnodes import pending_xref
from sphinx.environment import BuildEnvironment

__TARGET_SUBSTITUTIONS = {
    "sp.Expr": "sympy.core.expr.Expr",
    "sp.Symbol": "sympy.core.symbol.Symbol",
    "typing_extensions.Protocol": "typing.Protocol",
}
__REF_TYPE_SUBSTITUTIONS = {
    "ParameterValue": "obj",
    "ampform.dynamics.builder.BuilderReturnType": "obj",
}


try:  # Sphinx >=4.4.0
    # https://github.com/sphinx-doc/sphinx/blob/v4.4.0/sphinx/domains/python.py#L110-L133
    from sphinx.addnodes import pending_xref_condition
    from sphinx.domains.python import parse_reftarget

    def new_type_to_xref(
        target: str,
        env: BuildEnvironment = None,
        suppress_prefix: bool = False,
    ) -> pending_xref:
        """Convert a type string to a cross reference node."""
        if env:
            kwargs = {
                "py:module": env.ref_context.get("py:module"),
                "py:class": env.ref_context.get("py:class"),
            }
        else:
            kwargs = {}

        reftype, target, title, refspecific = parse_reftarget(
            target, suppress_prefix
        )
        target = __TARGET_SUBSTITUTIONS.get(target, target)
        reftype = __REF_TYPE_SUBSTITUTIONS.get(target, reftype)

        short_name = title.split(".")[-1]
        assert env is not None
        if env.config.python_use_unqualified_type_names:
            contnodes: List[nodes.Node] = [
                pending_xref_condition("", short_name, condition="resolved"),
                pending_xref_condition("", title, condition="*"),
            ]
        else:
            contnodes = [nodes.Text(short_name)]

        return pending_xref(
            "",
            *contnodes,
            refdomain="py",
            reftype=reftype,
            reftarget=target,
            refspecific=refspecific,
            **kwargs,
        )

except ImportError:  # Sphinx <4.4.0
    # https://github.com/sphinx-doc/sphinx/blob/v4.3.2/sphinx/domains/python.py#L83-L107
    def new_type_to_xref(
        target: str,
        env: BuildEnvironment = None,
        suppress_prefix: bool = False,
    ) -> pending_xref:
        # pylint: disable=unused-argument
        """Convert a type string to a cross reference node."""
        if target == "None":
            reftype = "obj"
        else:
            reftype = "class"

        if env:
            kwargs = {
                "py:module": env.ref_context.get("py:module"),
                "py:class": env.ref_context.get("py:class"),
            }
        else:
            kwargs = {}
        target = __TARGET_SUBSTITUTIONS.get(target, target)
        reftype = __REF_TYPE_SUBSTITUTIONS.get(target, reftype)

        short_name = target.split(".")[-1]
        assert env is not None
        if env.config.python_use_unqualified_type_names:
            # Note: It would be better to use qualname to describe the object to support support
            # nested classes.  But python domain can't access the real python object because this
            # module should work not-dynamically.
            contnodes: List[nodes.Node] = [
                pending_xref_condition("", short_name, condition="resolved"),
                pending_xref_condition("", target, condition="*"),
            ]
        else:
            contnodes = [nodes.Text(short_name)]

        return pending_xref(
            "",
            *contnodes,
            refdomain="py",
            reftype=reftype,
            reftarget=target,
            **kwargs,
        )


def abbreviate_signature() -> None:
    sphinx.domains.python.type_to_xref = new_type_to_xref
